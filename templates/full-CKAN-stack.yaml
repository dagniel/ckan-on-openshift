apiVersion: v1
kind: Template
metadata:
  name: ckan-full-stack
  annotations:
    description: |-
      Template for deploying the entire stack for CKAN

      Template for components without persistent storage(ephemeral)
    iconClass: icon-python
    openshift.io/display-name: Ckan(ephemeral) full
    tags: ckan,python,postgres,redis,solr,datapusher
    template.openshift.io/long-description: >-
      Template for deploying the entire stack for CKAN

      Template for components without persistent storage(ephemeral)
parameters:
- name: NAME
  displayName: Application name
  description: The name assigned to all of the frontend objects defined in this template.
  value: ckan
  required: true
- name: NAMESPACE
  displayName: Namespace
  description: The OpenShift Namespace where the resources will be created.
  value: sec-ckan
  required: true
- name: CKAN_VERSION
  displayName: Version of the deployment
  description: |-
    Tag should mirror the source repository/version tag/branch for ckan.
    Used for multiple components
  required: true
  value: "ckan-2.8.2"
- name: APPLICATION_HOSTNAME
  displayName: Application Hostname
  description: >-
    The exposed hostname that will route to the ckan service, if left blank
    a value will be defaulted.
  value: 'ckan.apps.oshift-pinfold.intra'
- name: SOLR_VERSION
  displayName: Base builder's source image
  description: |-
    Base builder's source image name used to create the app's specific builder
    Must be in the form image:tag
  value: "6.6.5"
- name: DATAPUSHER_VERSION
  displayName: Source code repository Reference
  description: >-
    Set this to a branch name, tag or other ref of your repository if you are
    not using the default branch.
  value: "0.0.15"
- name: PG_VERSION
  displayName: Base builder's source image for postgres
  description: |-
    Base builder's source image name used to create the app's specific builder for postgres
    Must be in the form image:tag
  value: "centos7-9.6.14-2.4.1"
- name: CONFIG_REPO_BRANCH
  displayName: Configuration repository reference
  description: >-
    Set this to a branch name, tag or other ref of your repository if you are
    not using the default branch.
  value: "master"
- name: SOLR_RAM_LIMIT
  displayName: Max ram allocatable for the solr container
  description: |-
    Option needed due to java1.8 limitation regarding container memory
    More at: https://developers.redhat.com/blog/2017/04/04/openjdk-and-containers/
  value: "512Mi"
  required: true
- name: SOLR_RAM_REQ
  displayName: Initial ram allocated for the solr container
  value: "256Mi"
- name: SOLR_CPU_REQ
  displayName: Initial CPU allocated for the solr container
  value: "50m"
- name: SOLR_CPU_LIMIT
  displayName: CPU limit for the solr container
  value: "200m"
- name: DATAPUSHER_RAM_LIMIT
  displayName: Max ram allocatable for the Datapusher container
  value: "256Mi"
  required: true
- name: DATAPUSHER_RAM_REQ
  displayName: Initial ram allocated for the Datapusher container
  value: "64Mi"
- name: DATAPUSHER_CPU_REQ
  displayName: Initial CPU allocated for the Datapusher container
  value: "50m"
- name: DATAPUSHER_CPU_LIMIT
  displayName: CPU limit for the Datapusher container
  value: "200m"
- name: REDIS_RAM_LIMIT
  displayName: Max ram allocatable for the REDIS container
  value: "512Mi"
  required: true
- name: REDIS_RAM_REQ
  displayName: Initial ram allocated for the REDIS container
  value: "128Mi"
- name: REDIS_CPU_REQ
  displayName: Initial CPU allocated for the REDIS container
  value: "50m"
- name: REDIS_CPU_LIMIT
  displayName: CPU limit for the REDIS container
  value: "200m"
- name: CKAN_RAM_LIMIT
  displayName: Max ram allocatable for the Datapusher container
  value: "512Mi"
  required: true
- name: CKAN_RAM_REQ
  displayName: Initial ram allocated for the Datapusher container
  value: "128Mi"
- name: CKAN_CPU_REQ
  displayName: Initial CPU allocated for the Datapusher container
  value: "200m"
- name: CKAN_CPU_LIMIT
  displayName: CPU limit for the Datapusher container
  value: "500m"
- name: ENV_TZ
  displayName: Environment for timezone
  description: |-
    OShift environment variable inserted in Pod to set the environment variable for the timezone used by the base container.
    Useful for logging
  value: "Europe/Amsterdam"
## generated by expressions
- name: PG_PRIMARY_PASSWORD
  displayName: Password for replication user(generated)
  description: |-
    This is automatically generated by the Openshift template and kept
    inside Postgres's env Secret.
    Should be left as is unless you want a more user-friendly value.
  from: '[a-z0-9]{8}'
  generate: expression
  required: true
- name: PG_PASSWORD
  displayName: Password for datastore primary user
  description: |-
    This is automatically generated by the Openshift template and kept
    inside Postgres's env Secret.
    Should be left as is unless you want a more user-friendly value.
  from: '[a-z0-9]{8}'
  generate: expression
  required: true
- name: PG_ROOT_PASSWORD
  displayName: Password for user postgres(generated)
  description: |-
    This is automatically generated by the Openshift template and kept
    inside Postgres's env Secret.
    Should be left as is unless you want a more user-friendly value.
  from: '[a-z0-9]{8}'
  generate: expression
  required: true
- name: PG_DS_RO_PASS
  displayName: Password for datastore read-only user
  description: |-
    This is automatically generated by the Openshift template and kept
    inside Postgres's env Secret.
    Should be left as is unless you want a more user-friendly value.
  from: '[a-z0-9]{8}'
  generate: expression
  required: true
- name: CKAN_APP_UUID
  displayName: Unique id needed by CKAN(conf)
  description: |-
    This is automatically generated by the Openshift template and kept inside CKAN's .ini file
    Should be left as is
  from: '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
  generate: expression
  required: true
- name: CKAN_BEAKER_SECRET
  displayName: Secret needed by CKAN(conf)
  description: |-
    This is automatically generated by the Openshift template and kept inside CKAN's .ini file
    Should be left as is
  from: '[a-zA-Z0-9]{25}'
  generate: expression
  required: true
objects:
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: First layer build to obtain solr image specific to ckan
    labels:
      app: ${NAME}
      app.component: solr
    name: ${NAME}-solr-base
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}-solr:base-${CKAN_VERSION}
        namespace: ${NAMESPACE}
    runPolicy: Serial
    source:
      type: Git
      git:
        ref: ${CKAN_VERSION}
        uri: "https://github.com/ckan/ckan.git"
    strategy:
      type: Docker
      dockerStrategy:
        dockerfilePath: "contrib/docker/solr/Dockerfile"
        from:
          kind: DockerImage
          name: docker.io/solr:${SOLR_VERSION}
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
#not linking the generic builder to the app's builder
    - type: ConfigChange
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: Second layer build to modify permissions in order to suit OKD requirements
    labels:
      app: ${NAME}
      app.component: solr
    name: ${NAME}-solr
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}-solr:${CKAN_VERSION}
        namespace: ${NAMESPACE}
    runPolicy: Serial
    source:
      type: Git
      git:
        ref: ${CONFIG_REPO_BRANCH}
        uri: "https://github.com/dagniel/ckan-on-openshift.git"
      contextDir: "docker/solr/${SOLR_VERSION}"
# used with a private repo
#        sourceSecret:
#          name: ${BASEBUILDER_REPO_AUTH}
    strategy:
      dockerStrategy:
        from:
          kind: ImageStreamTag
          name: ${NAME}-solr:base-${CKAN_VERSION}
          namespace: ${NAMESPACE}
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChange: {}
- apiVersion: v1
  kind: ImageStream
  metadata:
    annotations:
      description: Keeps track of changes in the final/OKD specific image
    labels:
      app: ${NAME}
      app.component: solr
    name: ${NAME}-solr
    namespace: ${NAMESPACE}
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      description: Exposes and load balances the application pods
    labels:
      app: ${NAME}
      app.component: solr
    name: ${NAME}-solr
    namespace: ${NAMESPACE}
  spec:
    ports:
    - name: solr
      port: 8983
      protocol: TCP
      targetPort: 8983
    selector:
      deploymentconfig: ${NAME}-solr
    type: ClusterIP
- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    annotations:
      description: Defines how to deploy the application server
    labels:
      app: ${NAME}
      app.component: solr
    name: ${NAME}-solr
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    revisionHistoryLimit: 5
    selector:
      app: ${NAME}
    template:
      metadata:
        labels:
          app: ${NAME}
          app.component: solr
          deploymentconfig: ${NAME}-solr
      spec:
        containers:
        - image: null
          imagePullPolicy: Always
          name: ${NAME}-solr
          ports:
          - containerPort: 8983
            protocol: TCP
          env:
            - name: TZ
              value: ${ENV_TZ}
            - name: SOLR_RAM_LIMIT
              valueFrom:
                resourceFieldRef:
                  resource: limits.memory
          livenessProbe:
            httpGet:
              path: /
              port: 8983
            initialDelaySeconds: 30
            timeoutSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 8983
            initialDelaySeconds: 30
            timeoutSeconds: 3
          resources:
            limits:
              cpu: ${SOLR_CPU_LIMIT}
              memory: ${SOLR_RAM_LIMIT}
            requests:
              cpu: ${SOLR_CPU_REQ}
              memory: ${SOLR_RAM_REQ}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
            - mountPath: /opt/config
              name: solr-config
# in order to use same ConfigMap for both the initialization script and for the optional startup configuration
# need to define a second mount point(the same ConfigMap is mounted twice)
            - mountPath: /docker-entrypoint-initdb.d
              name: solr-init
        volumes:
# the volume holds the ckan-solr-init.sh script even though it's not used in here
        - name: solr-config
          configMap:
            defaultMode: 0660
            optional: true
            name: solr-conf
# the volume only holds  the ckan-solr-init.sh script and not the optional startup config
#  in order to to avoid problematic script executions
        - name: solr-init
          configMap:
            defaultMode: 0770
            optional: true
            name: solr-conf
            items:
            - key: ckan-solr-init.sh
              path: ckan-solr-init.sh
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        automountServiceAccountToken: false
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChangeParams:
        automatic: true
        containerNames:
        - ${NAME}-solr
        from:
          kind: ImageStreamTag
          name: ${NAME}-solr:${CKAN_VERSION}
          namespace: ${NAMESPACE}
    strategy:
      type: Rolling
      activeDeadlineSeconds: 21600
      resources: {}
      rollingParams:
        intervalSeconds: 1
        maxSurge: 25%
        maxUnavailable: 0
        timeoutSeconds: 180
        updatePeriodSeconds: 1
- apiVersion: v1
  kind: ConfigMap
  metadata:
    annotations:
      description: |-
        Holds configuration and initialization files used to deploy Solr.
    labels:
      app: ${NAME}
      app.component: solr
    name: solr-conf
    namespace: ${NAMESPACE}
  data:
    ckan-solr-init.sh: |-
      #!/bin/bash

      # if there is a solr.in.sh file mounted in the /opt/config directory use this for starting Solr
      if [ -s "/opt/config/solr.in.sh" ]; then
        echo "---> Found user supplied solr.in.sh; Using it to start Solr"
        rm -f /opt/solr/bin/solr.in.sh
        cp /opt/config/solr.in.sh /opt/solr/bin/solr.in.sh
      fi


      #need to specify additional JAVA_OPTS to make Java respect container limits
      #https://docs.okd.io/3.10/dev_guide/application_memory_sizing.html#sizing-openjdk
      #if java major version is lower than 10, should add the -XX:MaxRAM option
      java -version > /tmp/jvers 2>&1
      jvers=$(cat /tmp/jvers | head -1 | cut -d ' ' -f3 | sed 's/\"\([0-9]*\).*/\1/')
      rm -f /tmp/jvers

      if [ 10 -gt $jvers ]; then
          if [ -z "$SOLR_RAM_LIMIT" ]; then
            SOLR_RAM_LIMIT="512Mi"
            echo "---> using default SOLR_RAM_LIMIT as: $SOLR_RAM_LIMIT"
          fi
          #when env variable comes linked to OKD mem limit notation,eg 512M or 512 Mi,
          #should change it to java size equivalent notation
          value=$(echo "$SOLR_RAM_LIMIT" | sed 's/\([0-9]*\)[a-zA-Z]*/\1/')
          suffix=$(echo "$SOLR_RAM_LIMIT" | sed 's/\([0-9]*\)\([a-zA-Z]*\)/\2/')

          #the case where there's no scale (Mi, GI, etc) then the value is in bytes
          if [ "x"$suffix = "x" ]; then
              SOLR_RAM_LIMIT=$(awk "BEGIN {print $value/1024/1024}")"m"
          # if suffix has len=1 => OKD decimal scale; approximate only the top factor
          elif [ ${#suffix} -eq 1 ]; then
              SOLR_RAM_LIMIT=$(awk "BEGIN {print $value/1024*1000}")"${suffix:0:1}"
          # if suffix has len>1 => OKD binary scale
          else
              SOLR_RAM_LIMIT=$value"${suffix:0:1}"
          fi

          echo "---> adding -XX:MaxRAM=$SOLR_RAM_LIMIT option for java version < 10"
          # if there is an active SOLR_OPTS variable, just append the MaxRam arg
          # otherwise(default) also add tuning for JVM memory release
          active_opts=$(sed -n "s/^SOLR_OPTS=\(.*\)\"/\1/p" /opt/solr/bin/solr.in.sh)
          if [ ${#active_opts} -eq 0 ]; then
              echo >> /opt/solr/bin/solr.in.sh
              echo "SOLR_OPTS=\"$SOLR_OPTS -XX:MaxRAM=$SOLR_RAM_LIMIT -XX:MinHeapFreeRatio=5 -XX:MaxHeapFreeRatio=10 -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90\"" \
              >> /opt/solr/bin/solr.in.sh
          else
              # for convenience modifies all the occurences
              sed -i "s/^\(#*\)\(SOLR_OPTS=\)\(.*\)\"/\1\2\3 -XX:MaxRAM=$SOLR_RAM_LIMIT\"/" /opt/solr/bin/solr.in.sh
          fi
          active_opts=$(sed -n "s/^SOLR_OPTS=\(.*\)\"/\1/p" /opt/solr/bin/solr.in.sh)
        echo "---> active SOLR_OPTS: $active_opts"
      fi
### END SOLR
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: S2I build to install and run application
    labels:
      app: ${NAME}
      app.component: datapusher
    name: ${NAME}-datapusher
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}-datapusher:${DATAPUSHER_VERSION}
        namespace: ${NAMESPACE}
    source:
      type: Git
      git:
        ref: ${DATAPUSHER_VERSION}
        uri: "https://github.com/ckan/datapusher.git"
    strategy:
      sourceStrategy:
        env:
          - name: DISABLE_SETUP_PY_PROCESSING
            value: "true"
          - name: UPGRADE_PIP_TO_LATEST
            value: "true"
        from:
          kind: DockerImage
          name: "docker.io/centos/python-27-centos7"
        incremental: true
      type: Source
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
    - type: ConfigChange
- apiVersion: v1
  kind: ImageStream
  metadata:
    annotations:
      description: Keeps track of changes in the final/OKD specific image
    labels:
      app: ${NAME}
      app.component: datapusher
    name: ${NAME}-datapusher
    namespace: ${NAMESPACE}
- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    annotations:
      description: Defines how to deploy the application server
    labels:
      app: ${NAME}
      app.component: datapusher
    name: ${NAME}-datapusher
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    revisionHistoryLimit: 5
    selector:
      app: ${NAME}
    template:
      metadata:
        labels:
          app: ${NAME}
          app.component: datapusher
          deploymentconfig: ${NAME}-datapusher
      spec:
        containers:
        - image: null
          imagePullPolicy: Always
          name: ${NAME}-datapusher
          command:
            - /bin/bash
            - '-c'
            - |
              echo -e "#!"/"bin"/"bash\npython $HOME/datapusher/main.py $HOME/deployment/datapusher_settings.py\n" > $HOME/app.sh && \
              chmod ug+rwx $HOME/app.sh && \
              $STI_SCRIPTS_PATH/run
          env:
            - name: TZ
              value: ${ENV_TZ}
          ports:
          - containerPort: 8800
            protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: 8800
            initialDelaySeconds: 30
            timeoutSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 8800
            initialDelaySeconds: 30
            timeoutSeconds: 10
          resources:
            limits:
              cpu: ${DATAPUSHER_CPU_LIMIT}
              memory: ${DATAPUSHER_RAM_LIMIT}
            requests:
              cpu: ${DATAPUSHER_CPU_REQ}
              memory: ${DATAPUSHER_RAM_REQ}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        automountServiceAccountToken: false
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChangeParams:
        automatic: true
        containerNames:
        - ${NAME}-datapusher
        from:
          kind: ImageStreamTag
          name: ${NAME}-datapusher:${DATAPUSHER_VERSION}
          namespace: ${NAMESPACE}
    strategy:
      type: Rolling
      activeDeadlineSeconds: 21600
      resources: {}
      rollingParams:
        intervalSeconds: 1
        maxSurge: 25%
        maxUnavailable: 0
        timeoutSeconds: 180
        updatePeriodSeconds: 1
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app.component: datapusher
      app: ${NAME}
    name: ${NAME}-datapusher
  spec:
    ports:
    - name: datapusher
      port: 8800
      protocol: TCP
      targetPort: 8800
    selector:
      deploymentconfig: ${NAME}-datapusher
### END DATAPUSHER
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    labels:
      app.component: redis
      app: ${NAME}
    name: ${NAME}-redis
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    selector:
      deploymentconfig: ${NAME}-redis
    strategy:
      resources: {}
      type: Recreate
    template:
      metadata:
        creationTimestamp: null
        labels:
          app.component: redis
          app: ${NAME}
          deploymentconfig: ${NAME}-redis
      spec:
        containers:
        - name: ${NAME}-redis
          args:
          - /etc/redis.d/redis.conf
          - --daemonize
          - "no"
          command:
          - /opt/rh/rh-redis32/root/usr/bin/redis-server
          image: "centos/redis-32-centos7:3.2"
          imagePullPolicy: IfNotPresent
          env:
            - name: TZ
              value: ${ENV_TZ}
          livenessProbe:
            initialDelaySeconds: 10
            periodSeconds: 5
            tcpSocket:
              port: 6379
          readinessProbe:
            exec:
              command:
              - container-entrypoint
              - bash
              - -c
              - redis-cli set liveness-probe "`date`" | grep OK
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          resources:
            limits:
              cpu: ${REDIS_CPU_LIMIT}
              memory: ${REDIS_RAM_LIMIT}
            requests:
              cpu: ${REDIS_CPU_REQ}
              memory: ${REDIS_RAM_REQ}
          terminationMessagePath: /dev/termination-log
          volumeMounts:
          - mountPath: /var/lib/redis/data
            name: redis-storage
          - mountPath: /etc/redis.d/
            name: ${NAME}-redis
        volumes:
        - name: redis-storage
          emptyDir: {}
        - configMap:
            items:
            - key: redis.conf
              path: redis.conf
            name: ${NAME}-redis
          name: ${NAME}-redis
    test: false
    triggers:
    - type: ConfigChange
- apiVersion: v1
  kind: ConfigMap
  metadata:
    labels:
      app.component: redis
      app: ${NAME}
    name: ${NAME}-redis
  data:
    redis.conf: |
      protected-mode no

      port 6379

      timeout 0
      tcp-keepalive 300

      daemonize no
      supervised no

      loglevel notice

      databases 16

      save 900 1
      save 300 10
      save 60 10000

      stop-writes-on-bgsave-error yes

      rdbcompression yes
      rdbchecksum yes

      dbfilename dump.rdb

      slave-serve-stale-data yes
      slave-read-only yes

      repl-diskless-sync no
      repl-disable-tcp-nodelay no

      appendonly yes
      appendfilename "appendonly.aof"
      appendfsync everysec
      no-appendfsync-on-rewrite no
      auto-aof-rewrite-percentage 100
      auto-aof-rewrite-min-size 64mb
      aof-load-truncated yes

      lua-time-limit 5000

      activerehashing no

      aof-rewrite-incremental-fsync yes
      dir /var/lib/redis/data
- apiVersion: v1
  kind: Service
  metadata:
    creationTimestamp: null
    labels:
      app.component: redis
      app: ${NAME}
    name: ${NAME}-redis
  spec:
    ports:
    - name: redis
      port: 6379
      protocol: TCP
      targetPort: 6379
    selector:
      deploymentconfig: ${NAME}-redis
## END REDIS
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${NAME}-postgresql
    namespace: ${NAMESPACE}
    labels:
      app: ${NAME}
      app.component: postgresql
  data:
#    pg_hba.conf: |
#      host all  all    0.0.0.0/0  md5
    setup.sql: |-
      SET application_name="container_setup";

      create extension postgis;
      create extension postgis_topology;
      create extension fuzzystrmatch;
      create extension postgis_tiger_geocoder;
      create extension pg_stat_statements;
      create extension pgaudit;
      create extension plr;

      alter user postgres password 'PG_ROOT_PASSWORD';

      create user PG_PRIMARY_USER with REPLICATION  PASSWORD 'PG_PRIMARY_PASSWORD';
      create user PG_USER with password 'PG_PASSWORD';

      create table primarytable (key varchar(20), value varchar(20));
      grant all on primarytable to PG_PRIMARY_USER;

      create database PG_DATABASE;

      grant all privileges on database PG_DATABASE to PG_USER;

      CREATE ROLE PG_DATASTORE_RO_USER NOSUPERUSER NOCREATEDB NOCREATEROLE LOGIN PASSWORD 'PG_DATASTORE_RO_PASS';
      CREATE DATABASE PG_DATASTORE_DB OWNER PG_USER ENCODING 'utf-8';
      GRANT ALL PRIVILEGES ON DATABASE PG_DATASTORE_DB TO PG_USER;

      \c PG_DATABASE

      create extension postgis;
      create extension postgis_topology;
      create extension fuzzystrmatch;
      create extension postgis_tiger_geocoder;
      create extension pg_stat_statements;
      create extension pgaudit;
      create extension plr;

      \c PG_DATABASE PG_USER;
- apiVersion: v1
  kind: Secret
  metadata:
    labels:
      app: ${NAME}
      app.component: postgresql
    name: ${NAME}-postgresql-env
    namespace: ${NAMESPACE}
  stringData:
    PG_PRIMARY_PORT: '5432'
    PGHOST: '/tmp'
    PG_MODE: primary
    PG_DATABASE: ckan
    PG_DATASTORE_DB: datastore
    PG_LOCALE: en_US.utf8
  type: Opaque
- apiVersion: v1
  kind: Secret
  metadata:
    labels:
      app: ${NAME}
      app.component: postgresql
    name: ${NAME}-postgresql-auth
    namespace: ${NAMESPACE}
  stringData:
    PG_PRIMARY_USER: replicator
    PG_PRIMARY_PASSWORD: ${PG_PRIMARY_PASSWORD}
    PG_USER: ckan
    PG_PASSWORD: ${PG_PASSWORD}
    PG_ROOT_PASSWORD: ${PG_ROOT_PASSWORD}
    PG_DATASTORE_RO_USER: datastore_ro
    PG_DATASTORE_RO_PASS: ${PG_DS_RO_PASS}
  type: Opaque
- apiVersion: v1
  kind: ImageStream
  metadata:
    annotations:
      description: Image stream for custom postgres-gis
    labels:
      app: ${NAME}
      app.component: postgresql
    name: ${NAME}-postgresql
    namespace: ${NAMESPACE}
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: First layer build to obtain app's specific builder scripts
    labels:
      app: ${NAME}
      app.component: postgresql
    name: ${NAME}-postgresql
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}-postgresql:${PG_VERSION}
        namespace: ${NAMESPACE}
    runPolicy: Serial
    source:
      type: Git
      git:
        ref: ${CONFIG_REPO_BRANCH}
        uri: "https://github.com/dagniel/ckan-on-openshift.git"
      contextDir: "docker/postgres-gis/${PG_VERSION}"
#      sourceSecret:
#        name: ${BASEBUILDER_REPO_AUTH}
    strategy:
      type: Docker
      dockerStrategy:
        env:
          - name: CONTAINER_USER_NAME
            value: postgres
        from:
          kind: DockerImage
          name: "docker.io/crunchydata/crunchy-postgres-gis:${PG_VERSION}"
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
    - type: ConfigChange
- kind: Service
  apiVersion: v1
  metadata:
    name: ${NAME}-postgresql
    labels:
      app: ${NAME}
      app.component: postgresql
  spec:
    ports:
    - name: postgresql
      protocol: TCP
      port: 5432
      targetPort: 5432
    selector:
      deploymentconfig: ${NAME}-postgresql
    type: ClusterIP
    sessionAffinity: None
- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    labels:
      app: ${NAME}
      app.component: postgresql
    name: ${NAME}-postgresql
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    revisionHistoryLimit: 5
    selector:
      app: ${NAME}
    template:
      metadata:
        labels:
          app: ${NAME}
          app.component: postgresql
          deploymentconfig: ${NAME}-postgresql
      spec:
        containers:
        - name: ${NAME}-postgresql
          image: null
          readinessProbe:
            exec:
              command:
              - "/opt/cpm/bin/readiness.sh"
            initialDelaySeconds: 40
            timeoutSeconds: 10
          livenessProbe:
            exec:
              command:
              - "/opt/cpm/bin/liveness.sh"
            initialDelaySeconds: 40
            timeoutSeconds: 10
          ports:
          - containerPort: 5432
            protocol: TCP
          env:
            - name: TZ
              value: ${ENV_TZ}
            - name: PG_PRIMARY_USER
              valueFrom:
                secretKeyRef:
                  key: PG_PRIMARY_USER
                  name: ${NAME}-postgresql-auth
            - name: PG_PRIMARY_PORT
              valueFrom:
                secretKeyRef:
                  key: PG_PRIMARY_PORT
                  name: ${NAME}-postgresql-env
            - name: PGHOST
              valueFrom:
                secretKeyRef:
                  key: PGHOST
                  name: ${NAME}-postgresql-env
            - name: PG_MODE
              valueFrom:
                secretKeyRef:
                  key: PG_MODE
                  name: ${NAME}-postgresql-env
            - name: PG_PRIMARY_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: PG_PRIMARY_PASSWORD
                  name: ${NAME}-postgresql-auth
            - name: PG_USER
              valueFrom:
                secretKeyRef:
                  key: PG_USER
                  name: ${NAME}-postgresql-auth
            - name: PG_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: PG_PASSWORD
                  name: ${NAME}-postgresql-auth
            - name: PG_DATABASE
              valueFrom:
                secretKeyRef:
                  key: PG_DATABASE
                  name: ${NAME}-postgresql-env
            - name: PG_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: PG_ROOT_PASSWORD
                  name: ${NAME}-postgresql-auth
            - name: PG_DATASTORE_DB
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_DB
                  name: ${NAME}-postgresql-env
            - name: PG_LOCALE
              valueFrom:
                secretKeyRef:
                  key: PG_LOCALE
                  name: ${NAME}-postgresql-env
            - name: PG_DATASTORE_RO_USER
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_RO_USER
                  name: ${NAME}-postgresql-auth
            - name: PG_DATASTORE_RO_PASS
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_RO_PASS
                  name: ${NAME}-postgresql-auth
          volumeMounts:
            - mountPath: "/pgdata"
              name: pgdata
              readOnly: false
            - mountPath: "/pgconf"
              name: pgconf
              readOnly: true
        volumes:
        - name: pgdata
          emptyDir: {}
        - name: pgconf
          configMap:
            name: ${NAME}-postgresql
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
#        securityContext: {}
# used for NFS backed persistence
#        securityContext:
#          supplementalGroups: [65534]
        terminationGracePeriodSeconds: 30
        automountServiceAccountToken: false
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChangeParams:
        automatic: true
        containerNames:
        - ${NAME}-postgresql
        from:
          kind: ImageStreamTag
          name: ${NAME}-postgresql:${PG_VERSION}
          namespace: ${NAMESPACE}
    strategy:
      type: Recreate
      resources: {}
## END POSTGRES
- apiVersion: v1
  kind: Secret
  metadata:
    annotations:
        description: |-
          Environment variables needed to setup and run the ckan container.
          These need to be synced with the contents of the production.ini ConfigurationMap
          Currently reference the services/auth from resources in the same project
    labels:
      app: ${NAME}
      app.component: ckan
    name: ${NAME}-env
    namespace: ${NAMESPACE}
  type: Opaque
  stringData:
# used to generate container user
    CONTAINER_USER_NAME: ckan
# env var for Docker build to install specific postgres client
    POSTGRES_TOOLS_VERSION: rh-postgresql96
# used in original Dockerfile; useful???
#    CKAN_HOME: /opt/app-root/src/ckan
# used in entrypoint and original Dockerfile; useful??
    CKAN_CONFIG: /opt/app-root/config
    CKAN_TEMPLATE_CONFIG: /opt/config
- apiVersion: v1
  kind: ImageStream
  metadata:
    annotations:
      description: Image stream for final ckan component
    labels:
      app: ${NAME}
      app.component: ckan
    name: ${NAME}
    namespace: ${NAMESPACE}
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: First layer build to obtain app's specific builder scripts
    labels:
      app: ${NAME}
      app.component: ckan
    name: ${NAME}-builder
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}:builder-${CKAN_VERSION}
        namespace: ${NAMESPACE}
    runPolicy: Serial
    source:
      type: Git
      git:
        ref: ${CONFIG_REPO_BRANCH}
        uri: "https://github.com/dagniel/ckan-on-openshift.git"
      contextDir: "docker/ckan/builder"
#      sourceSecret:
#        name: ${BASEBUILDER_REPO_AUTH}
    strategy:
      type: Docker
      dockerStrategy:
        env:
          - name: PGSQL_SCL
            valueFrom:
              secretKeyRef:
                key: POSTGRES_TOOLS_VERSION
                name: ${NAME}-env
        from:
          kind: DockerImage
          name: "docker.io/centos/python-27-centos7"
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
#not linking the generic builder to the app's builder
    - type: ConfigChange
- apiVersion: v1
  kind: BuildConfig
  metadata:
    annotations:
      description: S2I build to install and run ckan component
    labels:
      app: ${NAME}
      app.component: ckan
    name: ${NAME}
    namespace: ${NAMESPACE}
  spec:
    output:
      to:
        kind: ImageStreamTag
        name: ${NAME}:${CKAN_VERSION}
        namespace: ${NAMESPACE}
    source:
      type: Git
      git:
        ref: ${CKAN_VERSION}
        uri: "https://github.com/ckan/ckan.git"
    strategy:
      sourceStrategy:
        env:
          - name: DISABLE_SETUP_PY_PROCESSING
            value: ""
          - name: UPGRADE_PIP_TO_LATEST
            value: "true"
        from:
          kind: ImageStreamTag
          name: ${NAME}:builder-${CKAN_VERSION}
          namespace: ${NAMESPACE}
        incremental: true
      type: Source
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 5
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChange: {}
- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    annotations:
      description: Defines how to deploy the application server
    labels:
      app: ${NAME}
      app.component: ckan
    name: ${NAME}
    namespace: ${NAMESPACE}
  spec:
    replicas: 1
    revisionHistoryLimit: 5
    selector:
      app: ${NAME}
    template:
      metadata:
        labels:
          app: ${NAME}
          app.component: ckan
          deploymentconfig: ${NAME}
      spec:
        containers:
        - image: null
          imagePullPolicy: Always
          name: ${NAME}
          command:
            - /bin/bash
            - '-c'
            - $STI_SCRIPTS_PATH/run
          env:
            - name: TZ
              value: ${ENV_TZ}
            - name: PG_USER
              valueFrom:
                secretKeyRef:
                  key: PG_USER
                  name: ${NAME}-postgresql-auth
            - name: PG_DATASTORE_RO_PASS
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_RO_PASS
                  name: ${NAME}-postgresql-auth
            - name: PG_DATASTORE_RO_USER
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_RO_USER
                  name: ${NAME}-postgresql-auth
            - name: PG_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: PG_PASSWORD
                  name: ${NAME}-postgresql-auth
            - name: PG_DATABASE
              valueFrom:
                secretKeyRef:
                  key: PG_DATABASE
                  name: ${NAME}-postgresql-env
            - name: PG_DATASTORE_DB
              valueFrom:
                secretKeyRef:
                  key: PG_DATASTORE_DB
                  name: ${NAME}-postgresql-env
          envFrom:
            - secretRef:
                name: ${NAME}-env
            - configMapRef:
                name: ${NAME}
          ports:
          - containerPort: 5000
            protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: 5000
            initialDelaySeconds: 30
            timeoutSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 5000
            initialDelaySeconds: 30
            timeoutSeconds: 10
          resources:
            limits:
              cpu: ${CKAN_CPU_LIMIT}
              memory: ${CKAN_RAM_LIMIT}
            requests:
              cpu: ${CKAN_CPU_REQ}
              memory: ${CKAN_RAM_REQ}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
            - mountPath: /opt/app-root/storage
              name: ckan-storage
              readOnly: false
            - mountPath: /ckan-conf-templates
              name: template-config
              readOnly: true
        volumes:
        - name: ckan-storage
          emptyDir: {}
        - name: template-config
          configMap:
            defaultMode: 0440
            optional: true
            name: ${NAME}
            items:
            - key: ckan.ini
              path: ckan.ini
            - key: who.ini
              path: who.ini
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        automountServiceAccountToken: false
    triggers:
    - type: ConfigChange
    - type: ImageChange
      imageChangeParams:
        automatic: true
        containerNames:
        - ${NAME}
        from:
          kind: ImageStreamTag
          name: ${NAME}:${CKAN_VERSION}
          namespace: ${NAMESPACE}
    strategy:
      type: Rolling
      activeDeadlineSeconds: 21600
      resources: {}
      rollingParams:
        intervalSeconds: 1
        maxSurge: 25%
        maxUnavailable: 0
        timeoutSeconds: 180
        updatePeriodSeconds: 1
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app.component: ckan
      app: ${NAME}
    name: ${NAME}
  spec:
    ports:
    - name: ckan
      port: 5000
      protocol: TCP
      targetPort: 5000
    selector:
      deploymentconfig: ${NAME}
- apiVersion: v1
  kind: Route
  metadata:
    name: ${NAME}
    namespace: ${NAMESPACE}
    labels:
      app: ${NAME}
      app.component: ckan
    annotations:
      openshift.io/host.generated: "true"
  spec:
    host: '${APPLICATION_HOSTNAME}'
    port:
      targetPort: ckan
    to:
      kind: Service
      name: ${NAME}
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${NAME}
    namespace: ${NAMESPACE}
    annotations:
        description: |-
          Holds both key/value pairs that will be injected as environment variables in the running container
          and the ckan.ini configuration file for ckan

          If in template form (use of $VAR in content), it will be processed on deployment start and the $VARs
          will be changed with values from the equivalent values from the environment
          In this case the keys can be used inside the ckan.ini file.

          If in raw form the contents will be used as is

          The switch between template/raw type of processing is done via setting the CKAN_USE_CONF_TEMPLATE variable
           - "true" -> ckan.ini will be processed as template
           - empty or other value("false") -> ckan.ini will be copied and used as is
    labels:
      app: ${NAME}
      app.component: ckan
  data:
    CKAN_USE_CONF_TEMPLATE: "true"
    CKAN_DO_DB_INIT: "true"
    CKAN__PLUGINS: "stats text_view image_view recline_view datastore datapusher"
    POSTGRES_HOST: ${NAME}-postgresql.${NAMESPACE}.svc.cluster.local
    REDIS_HOST: ${NAME}-redis.${NAMESPACE}.svc.cluster.local
    REDIS_PORT: '6379'
    REDIS_DB: '1'
    SOLR_HOST: ${NAME}-solr.${NAMESPACE}.svc.cluster.local
    SOLR_PORT: '8983'
    DATAPUSHER_HOST: ${NAME}-datapusher.${NAMESPACE}.svc.cluster.local
    DATAPUSHER_PORT: '8800'
    CKAN_SITE_ID: okd-ckan
    CKAN_SITE_URL: http://${APPLICATION_HOSTNAME}
    CKAN_STORAGE_PATH: /opt/app-root/storage
    CKAN_MAX_UPLOAD_SIZE_MB: "30"
    CKAN_SMTP_MAIL_FROM: ckan@lab-okd.net
    CKAN_SMTP_PASSWORD: some_password
    CKAN_SMTP_SERVER: smtp.office365.com:587
    CKAN_SMTP_STARTTLS: "True"
    CKAN_SMTP_USER: account@office365.com
    CKAN_APP_UUID: ${CKAN_APP_UUID}
    CKAN_BEAKER_SECRET: ${CKAN_BEAKER_SECRET}
    ckan.ini: |-
      #
      # CKAN - Pylons configuration
      #
      # These are some of the configuration options available for your CKAN
      # instance. Check the documentation in 'doc/configuration.rst' or at the
      # following URL for a description of what they do and the full list of
      # available options:
      #
      # http://docs.ckan.org/en/latest/maintaining/configuration.html
      #
      # The %(here)s variable will be replaced with the parent directory of this file
      #

      [DEFAULT]

      # WARNING: *THIS SETTING MUST BE SET TO FALSE ON A PRODUCTION ENVIRONMENT*
      debug = false

      [server:main]
      use = egg:Paste#http
      host = 0.0.0.0
      port = 5000

      [app:main]
      use = egg:ckan
      full_stack = true
      cache_dir = /tmp/%(ckan.site_id)s/
      beaker.session.key = ckan

      # This is the secret token that the beaker library uses to hash the cookie sent
      # to the client. `paster make-config` generates a unique value for this each
      # time it generates a config file.
      beaker.session.secret = $CKAN_BEAKER_SECRET

      # `paster make-config` generates a unique value for this each time it generates
      # a config file.
      app_instance_uuid = $CKAN_APP_UUID

      # repoze.who config
      who.config_file = %(here)s/who.ini
      who.log_level = warning
      who.log_file = %(cache_dir)s/who_log.ini
      # Session timeout (user logged out after period of inactivity, in seconds).
      # Inactive by default, so the session doesn't expire.
      # who.timeout = 86400

      ## Database Settings
      sqlalchemy.url = postgresql://$PG_USER:$PG_PASSWORD@$POSTGRES_HOST/$PG_DATABASE

      ckan.datastore.write_url = postgresql://$PG_USER:$PG_PASSWORD@$POSTGRES_HOST/$PG_DATASTORE_DB
      ckan.datastore.read_url = postgresql://$PG_DATASTORE_RO_USER:$PG_DATASTORE_RO_PASS@$POSTGRES_HOST/$PG_DATASTORE_DB

      # PostgreSQL' full-text search parameters
      ckan.datastore.default_fts_lang = english
      ckan.datastore.default_fts_index_method = gist


      ## Site Settings

      ckan.site_url = $CKAN_SITE_URL
      #ckan.use_pylons_response_cleanup_middleware = true

      ## Authorization Settings

      ckan.auth.anon_create_dataset = false
      ckan.auth.create_unowned_dataset = false
      ckan.auth.create_dataset_if_not_in_organization = false
      ckan.auth.user_create_groups = false
      ckan.auth.user_create_organizations = false
      ckan.auth.user_delete_groups = true
      ckan.auth.user_delete_organizations = true
      ckan.auth.create_user_via_api = false
      ckan.auth.create_user_via_web = true
      ckan.auth.roles_that_cascade_to_sub_groups = admin


      ## Search Settings

      ckan.site_id = $CKAN_SITE_ID
      solr_url = http://$SOLR_HOST:$SOLR_PORT/solr/ckan


      ## Redis Settings

      # URL to your Redis instance, including the database to be used.
      ckan.redis.url = redis://$REDIS_HOST:$REDIS_PORT/$REDIS_DB


      ## CORS Settings

      # If cors.origin_allow_all is true, all origins are allowed.
      # If false, the cors.origin_whitelist is used.
      # ckan.cors.origin_allow_all = true
      # cors.origin_whitelist is a space separated list of allowed domains.
      # ckan.cors.origin_whitelist = http://example1.com http://example2.com


      ## Plugins Settings

      # Note: Add ``datastore`` to enable the CKAN DataStore
      #       Add ``datapusher`` to enable DataPusher
      #		Add ``resource_proxy`` to enable resorce proxying and get around the
      #		same origin policy
      ckan.plugins = $CKAN__PLUGINS

      # Define which views should be created by default
      # (plugins must be loaded in ckan.plugins)
      ckan.views.default_views = image_view text_view recline_view

      # Customize which text formats the text_view plugin will show
      #ckan.preview.json_formats = json
      #ckan.preview.xml_formats = xml rdf rdf+xml owl+xml atom rss
      #ckan.preview.text_formats = text plain text/plain

      # Customize which image formats the image_view plugin will show
      #ckan.preview.image_formats = png jpeg jpg gif

      ## Front-End Settings

      # Uncomment following configuration to enable using of Bootstrap 2
      #ckan.base_public_folder = public-bs2
      #ckan.base_templates_folder = templates-bs2

      ckan.site_title = CKAN
      ckan.site_logo = /base/images/ckan-logo.png
      ckan.site_description =
      ckan.favicon = /base/images/ckan.ico
      ckan.gravatar_default = identicon
      ckan.preview.direct = png jpg gif
      ckan.preview.loadable = html htm rdf+xml owl+xml xml n3 n-triples turtle plain atom csv tsv rss txt json
      ckan.display_timezone = server

      # package_hide_extras = for_search_index_only
      #package_edit_return_url = http://another.frontend/dataset/<NAME>
      #package_new_return_url = http://another.frontend/dataset/<NAME>
      #ckan.recaptcha.publickey =
      #ckan.recaptcha.privatekey =
      #licenses_group_url = http://licenses.opendefinition.org/licenses/groups/ckan.json
      # ckan.template_footer_end =


      ## Internationalisation Settings
      ckan.locale_default = en
      ckan.locale_order = en pt_BR ja it cs_CZ ca es fr el sv sr sr@latin no sk fi ru de pl nl bg ko_KR hu sa sl lv
      ckan.locales_offered =
      ckan.locales_filtered_out = en_GB

      ## Feeds Settings

      ckan.feeds.authority_name =
      ckan.feeds.date =
      ckan.feeds.author_name =
      ckan.feeds.author_link =

      ## Storage Settings

      ckan.storage_path = $CKAN_STORAGE_PATH
      ckan.max_resource_size = $CKAN_MAX_UPLOAD_SIZE_MB
      #ckan.max_image_size = 2

      ## Datapusher settings

      # Make sure you have set up the DataStore

      #ckan.datapusher.formats = csv xls xlsx tsv application/csv application/vnd.ms-excel application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
      ckan.datapusher.url = http://$DATAPUSHER_HOST:$DATAPUSHER_PORT
      #ckan.datapusher.assume_task_stale_after = 3600

      # Resource Proxy settings
      # Preview size limit, default: 1MB
      #ckan.resource_proxy.max_file_size = 1048576
      # Size of chunks to read/write.
      #ckan.resource_proxy.chunk_size = 4096

      ## Activity Streams Settings

      #ckan.activity_streams_enabled = true
      #ckan.activity_list_limit = 31
      #ckan.activity_streams_email_notifications = true
      #ckan.email_notifications_since = 2 days
      ckan.hide_activity_from_users = %(ckan.site_id)s


      ## Email settings

      #email_to = errors@example.com
      #error_email_from = ckan-errors@example.com
      smtp.server = $CKAN_SMTP_SERVER
      smtp.starttls = $CKAN_SMTP_STARTTLS
      smtp.user = $CKAN_SMTP_USER
      smtp.password = $CKAN_SMTP_PASSWORD
      smtp.mail_from = $CKAN_SMTP_MAIL_FROM

      ## Logging configuration
      [loggers]
      keys = root, ckan, ckanext

      [handlers]
      keys = console

      [formatters]
      keys = generic

      [logger_root]
      level = WARNING
      handlers = console

      [logger_ckan]
      level = INFO
      handlers = console
      qualname = ckan
      propagate = 0

      [logger_ckanext]
      level = DEBUG
      handlers = console
      qualname = ckanext
      propagate = 0

      [handler_console]
      class = StreamHandler
      args = (sys.stderr,)
      level = NOTSET
      formatter = generic

      [formatter_generic]
      format = %(asctime)s %(levelname)-5.5s [%(name)s] %(message)s
